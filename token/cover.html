
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">auth\token\ldap.go (0.0%)</option>
				
				<option value="file1">auth\token\session.go (71.7%)</option>
				
				<option value="file2">auth\token\user.go (76.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >//Package user provides list of function to authentication

//Search based on https://github.com/nmcclain/ldap/blob/master/examples/search.go
//Copyright 2014 The Go Authors. All rights reserved.
//Use of this source code is governed by a BSD-style
//license that can be found in the LICENSE file.

package token

import (
        . "auth/log"
        "errors"
        "fmt"

        "github.com/nmcclain/ldap"
)

var (
        ldapServer        = "in.ril.com"
        ldapPort   uint16 = 389
        baseDN            = "dc=in,dc=ril,dc=com"
        attributes        = []string{"memberof"}
)

const (
        //NoServerConnection used for connection error
        NoServerConnection string = "Unable to connect to LDAP server"

        //InvalidCredentials used for credential error
        InvalidCredentials string = "Invalid Credentials"

        //NoSearchData used for not able to find the details after binding
        NoSearchData string = "Check user is active"
)

//Authenticate check the given user has permission to bind and search same user
//it will return true when succesfully logged in
func Authenticate(user string, passwd string) (bool, error) <span class="cov0" title="0">{

        Logger.Debug("login in ", user)
        filter := "(&amp;(objectClass=user)(sAMAccountName=" + user + "))"
        user = "in\\" + user
        l, err := ldap.Dial("tcp", fmt.Sprintf("%s:%d", ldapServer, ldapPort))
        if err != nil </span><span class="cov0" title="0">{
                Logger.Errorf("ERROR: %s\n", err.Error())
                return false, errors.New(NoServerConnection)
        }</span>
        <span class="cov0" title="0">defer l.Close()
        // l.Debug = true

        err = l.Bind(user, passwd)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Errorf("ERROR: Cannot bind: %s\n", err.Error())
                return false, errors.New(InvalidCredentials)
        }</span>
        <span class="cov0" title="0">search := ldap.NewSearchRequest(
                baseDN,
                ldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,
                filter,
                attributes,
                nil)

        sr, err := l.Search(search)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Errorf("ERROR: %s\n", err.Error())
                return false, errors.New(NoSearchData)
        }</span>

        <span class="cov0" title="0">Logger.Debugf("Search: %s -&gt; num of entries = %d\n", search.Filter, len(sr.Entries))
        login := len(sr.Entries) &gt; 0

        return login, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package token

import (
        "flag"
        "fmt"
        "sync"

        . "auth/log"
        "auth/types"
        "time"

        "github.com/pborman/uuid"
)

var (
        lock  = &amp;sync.Mutex{}
        token = make(map[string]types.LoginUser)
        sto   float64
        //umap  = make(map[string]types.User)
)

type (

        //IAuthToken token interface
        IAuthToken interface {
                LoginUser(l types.LoginUser) (usr types.LoginUser, err error)
                AuthRoles(xauth string) (usr *types.User, err error)
                InitDB() (err error)
                TouchToken(xauth string) (err error)
                UpdateRoles(u types.User) (usr *types.User, err error)
        }

        //AuthToken token
        AuthToken struct {
                repo UserRepository
        }
)

func init() <span class="cov8" title="1">{
        flag.Float64Var(&amp;sto, "session.timeout", 2.0, "auth token session time out ")
}</span>

// CreateToken create new token
func CreateToken() string <span class="cov8" title="1">{
        lock.Lock()
        defer lock.Unlock()
        id := uuid.New()
        Logger.Debugf("new uuid created %s", id)
        return id
}</span>

// LoginUser login user
func (a *AuthToken) LoginUser(l types.LoginUser) (usr types.LoginUser, err error) <span class="cov8" title="1">{

        var login bool
        if l.Domain == "local" </span><span class="cov8" title="1">{
                login, err = a.repo.LoginUser(l.UserName, l.Password)
        }</span><span class="cov0" title="0"> else {
                login, err = Authenticate(l.UserName, l.Password)
        }</span>
        <span class="cov8" title="1">Logger.Debug("login status ", login)

        if err != nil </span><span class="cov8" title="1">{
                Logger.Error("login failed ", err.Error())
                return
        }</span>

        //if user already logged in send the same x-auth-token
        //update the LastUpdatedTime to now
        <span class="cov8" title="1">authToken := findExistingToken(l.UserName)
        usr = token[authToken]
        if usr == (types.LoginUser{}) </span><span class="cov8" title="1">{
                authToken = CreateToken()
                usr = types.LoginUser{
                        UserName:        l.UserName,
                        AuthToken:       authToken,
                        TokenCreateAt:   time.Now(),
                        LastUpdatedTime: time.Now(),
                }
                token[authToken] = usr

        }</span><span class="cov8" title="1"> else {
                usr.LastUpdatedTime = time.Now()
        }</span>

        <span class="cov8" title="1">return</span>
}

// Authenticate login interface method
func (a *AuthToken) Authenticate(l types.LoginUser) <span class="cov0" title="0">{

}</span>

// AuthRoles get roles for the given xauth token
// return invalid token error for unavailable user token
func (a *AuthToken) AuthRoles(xauth string) (r *types.User, err error) <span class="cov8" title="1">{

        u := token[xauth]
        if u == (types.LoginUser{}) </span><span class="cov0" title="0">{
                err = fmt.Errorf("Invalid token %s", xauth)
                return
        }</span>

        <span class="cov8" title="1">r, err = a.repo.Roles(u.UserName)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func findExistingToken(userName string) string <span class="cov8" title="1">{

        for key, u := range token </span><span class="cov8" title="1">{
                if u.UserName == userName </span><span class="cov8" title="1">{
                        return key
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

//ListTokens list avaiable tokens
func (a *AuthToken) ListTokens() map[string]types.LoginUser <span class="cov8" title="1">{
        return token
}</span>

// TocuhToken update active timestamp
func (a *AuthToken) TocuhToken(xauthToken string) (err error) <span class="cov8" title="1">{
        u := token[xauthToken]

        if u == (types.LoginUser{}) </span><span class="cov8" title="1">{
                err = fmt.Errorf("Invalid token %s", xauthToken)
                return
        }</span>
        <span class="cov8" title="1">Logger.Debugf("updated user %+v", u)
        // touch the time
        u.LastUpdatedTime = time.Now()
        return</span>
}

// InvalidateTokens find auth session are valid
func InvalidateTokens() <span class="cov0" title="0">{
        lock.Lock()
        defer lock.Unlock()

        for key, u := range token </span><span class="cov0" title="0">{
                if findTimeOut(u) </span><span class="cov0" title="0">{
                        delete(token, key)
                }</span>
        }
}

// find if the user is active or not
func findTimeOut(usr types.LoginUser) bool <span class="cov0" title="0">{
        now := time.Now()
        duration := now.Sub(usr.LastUpdatedTime)
        if duration.Minutes() &gt; sto </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// InitDB initalize DB
// wrapper class
func (a *AuthToken) InitDB() (err error) <span class="cov0" title="0">{
        err = NewDataAccess()
        return
}</span>

// UpdateRoles get roles for the given xauth token
// return invalid token error for unavailable user token
func (a *AuthToken) UpdateRoles(u types.User) (r *types.User, err error) <span class="cov8" title="1">{

        Logger.Debugf("user %s , team %s , roles %d", u.UserName, u.Team, u.Roles.ID)
        a.repo.UpdateRoles(u.UserName, u.Team, u.Roles.ID)
        r, err = a.repo.Roles(u.UserName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package token

import (
        "bytes"
        "flag"
        "fmt"
        "strconv"
        "strings"

        . "auth/log"
        "auth/types"

        // load sql driver
        _ "github.com/go-sql-driver/mysql"
        "github.com/jinzhu/gorm"
)

var (
        dbConn gorm.DB
        err    error
)

var (
        //CMDB configurations
        dbschema string
        dbip     string
        dbport   string
        user     string
        secret   string
)

func init() <span class="cov8" title="1">{
        flag.StringVar(&amp;dbschema, "db.schema", "cmdb", "db schema name")
        flag.StringVar(&amp;dbip, "db.ip", "127.0.0.1", "database ip address")
        flag.StringVar(&amp;dbport, "db.port", "3306", "database ip address")
        flag.StringVar(&amp;user, "db.user", "test", "database user name")
        flag.StringVar(&amp;secret, "db.password", "test123", "database password")
}</span>

type (

        // IUserRepository interface
        // set of  CURD operations on user and roles
        IUserRepository interface {
                LoginUser(user string, password string) (b bool, err error)
                UpdateRoles(user string, team string, roleID int) (usr types.User, err error)
                Roles(user string) (usr *types.User, err error)
        }

        //UserRepository empty struct
        UserRepository struct{}
)

// NewDataAccess create dbconnection
func NewDataAccess() (err error) <span class="cov8" title="1">{

        var buffer bytes.Buffer
        buffer.WriteString(fmt.Sprint(user, ":", secret, "@tcp(", dbip, ":", dbport, ")/", dbschema))
        Logger.Debug("\n MySQL Database Connection String :", buffer.String())
        dbURL := buffer.String()
        dbConn, err = gorm.Open("mysql", dbURL)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">dbConn.DB().Ping()
        dbConn.DB().SetMaxIdleConns(10)
        dbConn.DB().SetMaxOpenConns(20)
        dbConn.SingularTable(true)
        dbConn.LogMode(true)
        return</span>
}

// LoginUser get login user
func (u *UserRepository) LoginUser(user string, password string) (b bool, err error) <span class="cov8" title="1">{

        usr := new(types.LoginUser)
        err = dbConn.Find(&amp;usr, types.LoginUser{UserName: user, Password: password}).Error
        if err != nil </span><span class="cov8" title="1">{
                Logger.Error(err.Error())
                return
        }</span>

        <span class="cov8" title="1">if usr != nil </span><span class="cov8" title="1">{
                b = true
        }</span>
        <span class="cov8" title="1">Logger.Debugf("user %+v", usr)
        return</span>
}

// Roles get login user
// TODO : Object releation mapping is not working
// may be some sily mistake , not able to figure it out
// going for dirty fix - should be fixed after first release
/*func (u *UserRepository) Roles(user string) (usr *types.User, err error) {

        usr = &amp;types.User{UserName: user}
        var roles []types.Role

        err = dbConn.Find(&amp;usr, types.User{UserName: user}).Error
        err = dbConn.Model(&amp;usr).Related(&amp;roles).Error
        if err != nil {
                Logger.Error(err.Error())
                return
        }
        Logger.Debugf("User details %+v", usr)
        Logger.Debugf("Roles %+v", roles)
        return
}*/

// Roles get login user
func (u *UserRepository) Roles(user string) (usr *types.User, err error) <span class="cov8" title="1">{

        usr = new(types.User)
        err = dbConn.Find(&amp;usr, types.User{UserName: user}).Error
        if err != nil </span><span class="cov0" title="0">{
                Logger.Error("user details failed . ", err.Error())
                return
        }</span>

        <span class="cov8" title="1">query := " SELECT role_name  FROM t_user_role ur ,  t_role r WHERE ur.role_id = r.role_id  " +
                "AND  ur.user_id = " + strconv.Itoa(usr.ID)
        Logger.Debug("query - ", query)

        rows, err := dbConn.DB().Query(query)
        defer rows.Close()
        if err != nil </span><span class="cov0" title="0">{
                Logger.Error("Error ", err.Error())
                return
        }</span>
        <span class="cov8" title="1">var roleName string
        rows.Next()
        rows.Scan(&amp;roleName)

        Logger.Debugf("User - %v Role Name -  %v ", usr.UserName, roleName)
        r := types.Role{RoleName: roleName}
        p, err := findUserPermissions(usr.UserName)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Error("user roles failed ", err.Error())
                return
        }</span>
        // usr.Roles[0].Permission = FindUserPermissions(usr.UserName)
        <span class="cov8" title="1">r.Permission = p
        usr.Roles = r
        //usr.Roles = make([]types.Role, 1)
        //usr.Roles[0] = r

        return</span>
}

//findUserPermissions to get permission list for given user
func findUserPermissions(user string) (permissions []string, err error) <span class="cov8" title="1">{

        query := "SELECT  p.perm_key FROM  t_role_permission AS rp LEFT JOIN " +
                " t_user_role AS ur ON rp.role_id = ur.role_id " +
                " LEFT JOIN t_permission AS p ON rp.perm_id =p.perm_id " +
                " LEFT JOIN login_user AS u ON ur.user_id = u.user_id" +
                " WHERE  u.username = '" + user + "' "

        Logger.Debug("query : ", query)

        rows, err := dbConn.DB().Query(query)
        if err != nil </span><span class="cov0" title="0">{
                Logger.Error("Error ", err.Error())
                return
        }</span>

        <span class="cov8" title="1">var column string
        for rows.Next() </span><span class="cov8" title="1">{
                err = rows.Scan(&amp;column)
                if err != nil </span><span class="cov0" title="0">{
                        Logger.Error("Error ", err.Error())
                        return
                }</span>
                <span class="cov8" title="1">permissions = append(permissions, column)</span>
        }

        <span class="cov8" title="1">return</span>
}

// UpdateRoles add role to new user or exsiting user
func (u *UserRepository) UpdateRoles(user string, team string, roleID int) (s types.User, err error) <span class="cov8" title="1">{

        //find user availablity
        //var u types.User
        tx := dbConn.Begin()
        Logger.Debugf("user %s , team %s , roles %s", s.UserName, s.Team, s.Roles.ID)
        err = tx.Find(&amp;s, types.User{UserName: user}).Error
        if err != nil &amp;&amp; !strings.EqualFold(err.Error(), "record not found") </span><span class="cov0" title="0">{
                tx.Rollback()
                Logger.Error(err.Error())
                return
        }</span>
        <span class="cov8" title="1">Logger.Debugf("find user detail %+v", s)

        //if user not available , create new user
        if s.UserName == "" </span><span class="cov0" title="0">{
                s = types.User{UserName: user, Team: team}
                err = tx.Save(&amp;s).Error
                Logger.Debugf("New user added %s ", user)
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        Logger.Error("Saving user failed ", err.Error())
                        return
                }</span>
        }

        //TODO : Dirty fix again
        //since it
        <span class="cov8" title="1">var r types.UserRole
        err = tx.Find(&amp;r, types.UserRole{UserID: s.ID}).Error
        Logger.Debugf("user role details %+v ", r)

        //if r.UserRoleID == 0 {
        r.UserID = s.ID
        //}
        //update roles
        r.RoleID = roleID
        tx.Save(&amp;r)
        tx.Commit()

        Logger.Debugf("Roles added for the user %s ", user)
        return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
